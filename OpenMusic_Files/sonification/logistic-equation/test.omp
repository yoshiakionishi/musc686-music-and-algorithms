; OM File Header - Saved 2025/06/13 22:54:46
; (7.06 :patc (om-make-point 878/7 697/7) (om-make-point 214 47) (om-make-point 1097 727) "" 183 0 nil "2025/06/13 22:54:46")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "test" (quote ((let ((box (om-load-boxwithed1 (quote box-with-win) "omloop 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "x(n)" nil) (om-load-inputfun (quote input-funbox) "" "r" nil) (om-load-inputfun (quote input-funbox) "" "how many (n)" nil))) (om-make-point 870 266) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 498 132) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "FIRST-ARG" 0) (om-load-inputfun (quote input-funbox) "number or list" "SECOND-ARG" 0))) (om-make-point 488 162) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CREATE-LIST" (quote create-list) (quote ((om-load-inputfun (quote input-funbox) "number of elements" "COUNT" 10) (om-load-inputfun (quote input-funbox) "initial element" "ELEM" nil))) (om-make-point 286 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 265 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 436 130) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "x(n+1) = r*x(n)*(1-x(n))" (om-load-patch-abs1 "x(n+1) = r*x(n)*(1-x(n))" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 127 286) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "r" 1 (om-make-point 188 54) "" "r" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x(n)" 0 (om-make-point 95 54) "" "x(n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 112 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "FIRST-ARG" 0) (om-load-inputfun (quote input-funbox) "number or list" "SECOND-ARG" 0))) (om-make-point 186 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 145 146) (om-make-point 38 30) 1.0 "1.0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 133 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 6 0 nil 0) (4 0 6 1 nil 0))) 7.06 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 313 425/2) nil (list 0.5) "l" "x(n+1) = r*x(n)*(1-x(n))"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "accum" (quote accumulator) (quote ((om-load-inputfun (quote input-funbox) "items to collect" "DATA" nil) (om-load-inputfun (quote input-funbox) "initial value" "INIT" nil) (om-load-inputfun (quote input-funbox) "accumulation function" "FUN" nil))) (om-make-point 259 285) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "how many (n)" 2 (om-make-point 442 46) "" "how many (n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "r" 1 (om-make-point 145 55) "" "r" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x(n)" 0 (om-make-point 5 45) "" "x(n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 248 346) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 295 439) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 195 439) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (7 0 2 0 nil 0) (8 0 2 1 nil 0) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (1 0 4 1 nil 0) (3 0 6 0 nil 0) (9 0 6 1 nil 0) (5 0 6 2 nil 0) (6 0 10 0 nil 0) (10 1 11 0 nil 0) (10 0 12 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 803 207) (om-make-point 48 30) 1000 "1000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 734 208) (om-make-point 38 30) 0.5 "0.5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 688 208) (om-make-point 38 30) 0.2 "0.2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "omloop" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "x(n)" nil) (om-load-inputfun (quote input-funbox) "" "r" nil) (om-load-inputfun (quote input-funbox) "" "how many (n)" nil))) (om-make-point 722 266) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 131 203) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CREATE-LIST" (quote create-list) (quote ((om-load-inputfun (quote input-funbox) "number of elements" "COUNT" 10) (om-load-inputfun (quote input-funbox) "initial element" "ELEM" nil))) (om-make-point 172 140) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "x(n+1) = r*x(n)*(1-x(n))" (om-load-patch-abs1 "x(n+1) = r*x(n)*(1-x(n))" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 127 286) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "r" 1 (om-make-point 188 54) "" "r" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x(n)" 0 (om-make-point 95 54) "" "x(n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 112 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "FIRST-ARG" 0) (om-load-inputfun (quote input-funbox) "number or list" "SECOND-ARG" 0))) (om-make-point 186 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 145 146) (om-make-point 38 30) 1.0 "1.0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 133 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 6 0 nil 0) (4 0 6 1 nil 0))) 7.06 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 256 291/2) nil (list 0.5) "l" "x(n+1) = r*x(n)*(1-x(n))"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "accum" (quote accumulator) (quote ((om-load-inputfun (quote input-funbox) "items to collect" "DATA" nil) (om-load-inputfun (quote input-funbox) "initial value" "INIT" nil) (om-load-inputfun (quote input-funbox) "accumulation function" "FUN" nil))) (om-make-point 258 258) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "how many (n)" 2 (om-make-point 442 46) "" "how many (n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "r" 1 (om-make-point 145 55) "" "r" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x(n)" 0 (om-make-point 5 45) "" "x(n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 248 346) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 295 439) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 195 439) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (5 0 1 1 nil 0) (0 0 3 0 nil 0) (6 0 3 1 nil 0) (2 0 3 2 nil 0) (3 0 7 0 nil 0) (7 1 8 0 nil 0) (7 0 9 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "x(n+1) = r*x(n)*(1-x(n))" (om-load-patch-abs1 "x(n+1) = r*x(n)*(1-x(n))" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 127 286) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "r" 1 (om-make-point 192 54) "" "r" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "x(n)" 0 (om-make-point 88 54) "" "x(n)" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 112 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "FIRST-ARG" 0) (om-load-inputfun (quote input-funbox) "number or list" "SECOND-ARG" 0))) (om-make-point 186 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 145 146) (om-make-point 38 30) 1.0 "1.0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 133 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 6 0 nil 0) (4 0 6 1 nil 0))) 7.06 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 519 521/2) nil (list 0.5) nil "x(n+1) = r*x(n)*(1-x(n))"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FUNCALL" (quote funcall) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 103 366) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch 2" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 217 257) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 184 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 112 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "FIRST-ARG" 0) (om-load-inputfun (quote input-funbox) "number or list" "SECOND-ARG" 0))) (om-make-point 183 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 144 162) (om-make-point 38 30) 1.0 "1.0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 133 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 6 0 nil 0) (4 0 6 1 nil 0))) 7.06 nil "" (om-make-point 879 236) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 50 391/2) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 217 257) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 184 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 112 174) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "FIRST-ARG" 0) (om-load-inputfun (quote input-funbox) "number or list" "SECOND-ARG" 0))) (om-make-point 183 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 144 162) (om-make-point 38 30) 1.0 "1.0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 133 234) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (5 0 4 0 nil 0) (2 0 4 1 nil 0) (3 0 6 0 nil 0) (4 0 6 1 nil 0))) 7.06 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 153 413/2) nil (list 0.5) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 271 124) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 194 120) (om-make-point 38 30) 0.5 "0.5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 99 50) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 152 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (2 0 0 1 nil 0) (1 0 0 2 nil 0) (3 0 4 0 nil 0) (2 0 4 1 nil 0) (1 0 4 2 nil 0) (7 0 6 0 nil 0) (8 0 6 1 nil 0) (9 0 7 1 nil 0) (10 0 8 0 nil 0) (9 0 8 1 nil 0) (11 0 12 0 nil 0))) nil 7.06))