; OM File Header - Saved 2025/09/22 16:12:22
; (7.06 :patc (om-make-point 172 60) (om-make-point 50 50) (om-make-point 500 400) "" 183 0 "2025/09/22 15:21:42" "2025/09/22 15:53:38")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "music-algorithms-3-2" (quote ((let ((box (om-load-boxcomment "comment 2" (om-make-point 146 28) (quote "<< double-click me") nil (om-make-point 265 211) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 146 28) (quote "<< double-click me") nil (om-make-point 273 101) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 297 56) (quote "MUSC 686: Music and Algorithms (FA2025)$Session 3, Markov Chains$Supplement - car, cdr, mapcar, funcall") nil (om-make-point 45 21) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "on-mapcar-and-funcall" (om-load-patch-abs1 "on-mapcar-and-funcall" (quote ((let ((box (om-load-boxcomment "comment 2" (om-make-point 290 94) (quote "However, you will start to notice the difference when you use such functions as x-append. x-append is a function that combines (concatenates) two lists into one. ") nil (om-make-point 666 315) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 308 138) (quote "mapcar takes each of the items in the list to operate the lambda function (in this case, add 25 to each of the number), but funcall takes the number and literally say (om+ (list 1 2 3 4 5) 25) that is without going through the iterative, loop procedure. Both produces the same result, (26 27 28 29 30)") nil (om-make-point 155 317) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 153 85) (quote "both mapcar and funcall accept a lambda function. Push L to make the Greek L appear >>>") nil (om-make-point 59 138) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FUNCALL 2" (quote funcall) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 346 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 248 71) (quote "you can adjust the number of inputs on funcall by typing > or <, or alt/option+right or left key") nil (om-make-point 386 246) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 187 100) (quote "click on *mapcar* and *funcall* and push d to see the documentation (this is a useful trick for many of the OM functions!)") nil (om-make-point 215 41) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR 2" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 683 245) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 776 156) (om-make-point 70 30) (list 1 2 3 4 5) "(1 2 3 4 5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 698 131) (om-make-point 37 30) (list 4) "(4)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 671 161) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FUNCALL" (quote funcall) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 777 245) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 237 143) (om-make-point 34 30) 25 "25" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 226 269) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" 0))) (om-make-point 214 190) (om-make-point 57 35) nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 317 197) (om-make-point 70 30) (list 1 2 3 4 5) "(1 2 3 4 5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((13 0 3 0 nil 0) (14 0 3 1 nil 0) (9 0 6 0 nil 0) (7 0 6 1 nil 0) (8 0 9 1 nil 0) (9 0 10 0 nil 0) (7 0 10 1 nil 0) (13 0 12 0 nil 0) (14 0 12 1 nil 0) (11 0 13 1 nil 0))) 7.06 nil "" (om-make-point 200 200) (om-make-point 991 505)) (quote nil) (om-make-point 175 199) nil nil nil "on-mapcar-and-funcall"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 153 134) (quote "you can *encapsulate* a group of objects by selecting them all, then pushing shift+e. Or type the word patch and hit enter") nil (om-make-point 24 101) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "on-car-and-cdr" (om-load-patch-abs1 "on-car-and-cdr" (quote ((let ((box (om-load-boxcomment "comment 2" (om-make-point 310 93) (quote "When you have a nested list, you may have to use a clever combination. Try to make sense of this by reading from right to left, excluding c and r. ") nil (om-make-point 226 361) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADR 2" (quote cadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 79 435) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 476 66) (quote "car => the first item of a list (list level is lifted by 1)$cdr => the list in its entirety except the first item (the result will have a parentheses)$You may combine the car and cdr in different manners") nil (om-make-point 107 258) nil (om-make-color 0 0 0) (om-make-font "Courier New" 12.0D0 :family "Courier New" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADADR" (quote cadadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 195 440) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAADR" (quote caadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 132 437) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 113 387) (om-make-point 78 30) (list (quote a) (list (quote b) (quote c)) (quote d) (quote e)) "(a (b c) d e)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDDR" (quote cddr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 267 197) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADDR" (quote caddr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 385 195) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CADR" (quote cadr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 322 196) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CDR" (quote cdr) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 193 197) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 149 195) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 126 79) (om-make-point 68 30) (list (quote a) (quote b) (quote c) (quote d) (quote e)) "(a b c d e)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 1 0 nil 0) (5 0 3 0 nil 0) (5 0 4 0 nil 0) (11 0 6 0 nil 0) (11 0 7 0 nil 0) (11 0 8 0 nil 0) (11 0 9 0 nil 0) (11 0 10 0 nil 0))) 7.06 nil "" (om-make-point 200 200) (om-make-point 602 579)) (quote nil) (om-make-point 204 85) nil nil nil "on-car-and-cdr"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote nil) nil 7.06))
